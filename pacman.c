#include <stdio.h>
#include <conio.h>
#include <Windows.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#define BLACK 0
#define BLUE1 1
#define GREEN1 2
#define CYAN1 3
#define RED1 4
#define MAGENTA1 5
#define YELLOW1 6
#define GRAY1 7
#define GRAY2 8
#define BLUE2 9
#define GREEN2 10
#define CYAN2 11
#define RED2 12
#define MAGENTA2 13
#define YELLOW2 14
#define WHITE 15

#define ESC 0x1b //  ESC 누르면 종료
#define SPACE 32
#define ENTER 13

#define SPECIAL1 0xe0 // 특수키는 0xe0 + key 값으로 구성된다.
#define SPECIAL2 0x00 // keypad 경우 0x00 + key 로 구성된다.

// 1p 조작 키
#define UP  0x48 // Up key는 0xe0 + 0x48 두개의 값이 들어온다.
#define DOWN 0x50
#define LEFT 0x4b
#define RIGHT 0x4d

// 2p 조작 키
#define UP2		'w'
#define DOWN2	's'
#define LEFT2	'a'
#define RIGHT2	'd'

// 유령 회귀 방향
#define GUP		'i'
#define GDOWN	'j'
#define GLEFT	'k'
#define GRIGHT	'l'

// 메뉴 변수
#define GAMESTART 100
#define RANKING 101
#define HELP 102
#define EXIT 103
#define SINGLEMODE 111
#define COOPERATIONMODE 112
#define BATTLEMODE 113

// 게임 모드 변수
#define BATTLE 'B'
#define COOPERATION 'C'
#define SINGLE 'S'

// 화면 크기
#define WIDTH 80
#define HEIGHT 31

// 미로 크기
#define MSIZE_ROW 30
#define MSIZE_COL 32

// 개체 수
#define GHOST 10
#define PACMAN 2

// 유령 상태
#define DIE 'D'
#define LIVE 'L'
#define IMMORTAL 'I'


#define STACK_SIZE 2

// 전역변수
int Delay = 150;
int keep_moving = 1;
int spark1 = 0; // 움직임 효과에 대한 변수
int spark2 = 0;
int score = 0; //player1의 점수
int score2 = 0; // player2의 점수
int life1 = 3, life2 = 3; // player1,2의 라이프 수
int unbeatable = 0; // 팩맨의 무적변수
int start, present_time, rem_t; // 아이템효과 지속/시간에 대한 변수
int start2, present_time2, rem_t2; // player2 의 시간변수
int cnt; // 점수증가를 위한 유령포식의 횟수
int coin = 256; // 전체 코인 수
int f; // 애니메이션 움직임 변수
int stage; // 스테이지에 변수, 유령의 수가 달라짐
int C[2]; // 플레이어의 키보드 제어권 변수
int speed1 = 0;
int speed2[10] = { 0 };
int count1 = 0;
int count2[10] = { 0 };
char mode; // 현재 게임모드의 상태

		   // 유령정보 구조체
typedef struct {
	int ox;	int oy;
	int nx;	int ny;
	int tx; int ty; // t: trace(흔적)
	char direction;
	char status; // 생사 상태
	int timid; // 주눅모드
} ghostvector;

// 팩맨 정보 구조체
typedef struct {
	int ox;
	int oy;
	int nx;
	int ny;
	int status;
	unsigned char direction;
} pacmanvector;

#define FILENAME "rank.txt"
typedef struct rank {
	char name[20];
	int myscore;
} Rank;
FILE *fp;
Rank data;

// 유령 개체, 팩맨 개체
ghostvector g[GHOST];
pacmanvector p[PACMAN];

// 맵정의 (1: 벽, 2:꺾은길, 두갈래길, 3:삼거리 ,4:사거리, 5: 집 입구)
char map1[MSIZE_COL][MSIZE_ROW] = {
	{ '0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0' },
	{ '0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','0' },
	{ '0','1','2','0','0','0','0','3','0','0','0','0','0','2','1','1','2','0','0','0','0','0','3','0','0','0','0','2','1','0' },
	{ '0','1','0','1','1','1','1','0','1','1','1','1','1','0','1','1','0','1','1','1','1','1','0','1','1','1','1','0','1','0' },
	{ '0','1','0','1','0','0','1','0','1','0','0','0','1','0','1','1','0','1','0','0','0','1','0','1','0','0','1','0','1','0' },
	{ '0','1','0','1','1','1','1','0','1','1','1','1','1','0','1','1','0','1','1','1','1','1','0','1','1','1','1','0','1','0' },
	{ '0','1','3','0','0','0','0','4','0','0','3','0','0','3','0','0','3','0','0','3','0','0','4','0','0','0','0','3','1','0' },
	{ '0','1','0','1','1','1','1','0','1','1','0','1','1','1','1','1','1','1','1','0','1','1','0','1','1','1','1','0','1','0' },
	{ '0','1','0','1','1','1','1','0','1','1','0','1','1','1','1','1','1','1','1','0','1','1','0','1','1','1','1','0','1','0' },
	{ '0','1','2','0','0','0','0','3','1','1','2','0','0','2','1','1','2','0','0','2','1','1','3','0','0','0','0','2','1','0' },
	{ '0','1','1','1','1','1','1','0','1','1','1','1','1','0','1','1','0','1','1','1','1','1','0','1','1','1','1','1','1','0' },
	{ '0','0','0','0','0','0','1','0','1','1','1','1','1','0','1','1','0','1','1','1','1','1','0','1','0','0','0','0','0','0' },
	{ '0','0','0','0','0','0','1','0','1','1','2','0','0','3','5','5','3','0','0','2','1','1','0','1','0','0','0','0','0','0' },
	{ '0','0','0','0','0','0','1','0','1','1','0','1','1','1','3','3','1','1','1','0','1','1','0','1','0','0','0','0','0','0' },
	{ '1','1','1','1','1','1','1','0','1','1','0','1','3','3','3','3','3','3','1','0','1','1','0','1','1','1','1','1','1','1' },
	{ '0','0','0','0','0','0','0','4','0','0','3','1','3','3','3','3','3','3','1','3','0','0','4','0','0','0','0','0','0','0' },
	{ '1','1','1','1','1','1','1','0','1','1','0','1','3','3','3','3','3','3','1','0','1','1','0','1','1','1','1','1','1','1' },
	{ '0','0','0','0','0','0','1','0','1','1','0','1','1','1','1','1','1','1','1','0','1','1','0','1','0','0','0','0','0','0' },
	{ '0','0','0','0','0','0','1','0','1','1','3','0','0','0','0','0','0','0','0','3','1','1','0','1','0','0','0','0','0','0' },
	{ '0','0','0','0','0','0','1','0','1','1','0','1','1','1','1','1','1','1','1','0','1','1','0','1','0','0','0','0','0','0' },
	{ '0','1','1','1','1','1','1','0','1','1','0','1','1','1','1','1','1','1','1','0','1','1','0','1','1','1','1','1','1','0' },
	{ '0','1','2','0','0','0','0','4','0','0','3','0','0','2','1','1','2','0','0','3','0','0','4','0','0','0','0','2','1','0' },
	{ '0','1','0','1','1','1','1','0','1','1','1','1','1','0','1','1','0','1','1','1','1','1','0','1','1','1','1','0','1','0' },
	{ '0','1','0','1','1','1','1','0','1','1','1','1','1','0','1','1','0','1','1','1','1','1','0','1','1','1','1','0','1','0' },
	{ '0','1','2','0','2','1','1','3','0','0','3','0','0','3','0','0','3','0','0','3','0','0','3','1','1','2','0','2','1','0' },
	{ '0','1','1','1','0','1','1','0','1','1','0','1','1','1','1','1','1','1','1','0','1','1','0','1','1','0','1','1','1','0' },
	{ '0','1','1','1','0','1','1','0','1','1','0','1','1','1','1','1','1','1','1','0','1','1','0','1','1','0','1','1','1','0' },
	{ '0','1','2','0','3','0','0','2','1','1','2','0','0','2','1','1','2','0','0','2','1','1','2','0','0','3','0','2','1','0' },
	{ '0','1','0','1','1','1','1','1','1','1','1','1','1','0','1','1','0','1','1','1','1','1','1','1','1','1','1','0','1','0' },
	{ '0','1','0','1','1','1','1','1','1','1','1','1','1','0','1','1','0','1','1','1','1','1','1','1','1','1','1','0','1','0' },
	{ '0','1','2','0','0','0','0','0','0','0','0','0','0','3','0','0','3','0','0','0','0','0','0','0','0','0','0','2','1','0' },
	{ '0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','0' }
};

// 코인 아이템위치 (1:코인 있음, 0:없음)
char object[MSIZE_COL][MSIZE_ROW];
char OBJECT[MSIZE_COL][MSIZE_ROW] = {
	{ '0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0' },
	{ '0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0' },
	{ '0','0','1','1','1','1','1','1','1','1','1','1','1','1','0','0','1','1','1','1','1','1','1','1','1','1','1','1','0','0' },
	{ '0','0','1','0','0','0','0','1','0','0','0','0','0','1','0','0','1','0','0','0','0','0','1','0','0','0','0','1','0','0' },
	{ '0','0','2','0','0','0','0','1','0','0','0','0','0','1','0','0','1','0','0','0','0','0','1','0','0','0','0','2','0','0' },
	{ '0','0','1','0','0','0','0','1','0','0','0','0','0','1','0','0','1','0','0','0','0','0','1','0','0','0','0','1','0','0' },
	{ '0','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','0','0' },
	{ '0','0','1','0','0','0','0','1','0','0','1','0','0','0','0','0','0','0','0','1','0','0','1','0','0','0','0','1','0','0' },
	{ '0','0','1','0','0','0','0','1','0','0','1','0','0','0','0','0','0','0','0','1','0','0','1','0','0','0','0','1','0','0' },
	{ '0','0','1','1','1','1','1','1','0','0','1','1','1','1','0','0','1','1','1','1','0','0','1','1','1','1','1','1','0','0' },
	{ '0','0','0','0','0','0','0','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','1','0','0','0','0','0','0','0' },
	{ '0','0','0','0','0','0','0','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','1','0','0','0','0','0','0','0' },
	{ '0','0','0','0','0','0','0','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','1','0','0','0','0','0','0','0' },
	{ '0','0','0','0','0','0','0','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','1','0','0','0','0','0','0','0' },
	{ '0','0','0','0','0','0','0','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','1','0','0','0','0','0','0','0' },
	{ '0','1','1','1','1','1','1','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','1','1','1','1','1','1','1','0' },
	{ '0','0','0','0','0','0','0','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','1','0','0','0','0','0','0','0' },
	{ '0','0','0','0','0','0','0','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','1','0','0','0','0','0','0','0' },
	{ '0','0','0','0','0','0','0','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','1','0','0','0','0','0','0','0' },
	{ '0','0','0','0','0','0','0','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','1','0','0','0','0','0','0','0' },
	{ '0','0','0','0','0','0','0','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','1','0','0','0','0','0','0','0' },
	{ '0','0','1','1','1','1','1','1','1','1','1','1','1','1','0','0','1','1','1','1','1','1','1','1','1','1','1','1','0','0' },
	{ '0','0','1','0','0','0','0','1','0','0','0','0','0','1','0','0','1','0','0','0','0','0','1','0','0','0','0','1','0','0' },
	{ '0','0','1','0','0','0','0','1','0','0','0','0','0','1','0','0','1','0','0','0','0','0','1','0','0','0','0','1','0','0' },
	{ '0','0','2','1','1','0','0','1','1','1','1','1','1','1','0','0','1','1','1','1','1','1','1','0','0','1','1','2','0','0' },
	{ '0','0','0','0','1','0','0','1','0','0','1','0','0','0','0','0','0','0','0','1','0','0','1','0','0','1','0','0','0','0' },
	{ '0','0','0','0','1','0','0','1','0','0','1','0','0','0','0','0','0','0','0','1','0','0','1','0','0','1','0','0','0','0' },
	{ '0','0','1','1','1','1','1','1','0','0','1','1','1','1','0','0','1','1','1','1','0','0','1','1','1','1','1','1','0','0' },
	{ '0','0','1','0','0','0','0','0','0','0','0','0','0','1','0','0','1','0','0','0','0','0','0','0','0','0','0','1','0','0' },
	{ '0','0','1','0','0','0','0','0','0','0','0','0','0','1','0','0','1','0','0','0','0','0','0','0','0','0','0','1','0','0' },
	{ '0','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','0','0' },
	{ '0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0' }
};


// 유령 회귀(집으로) 루트 (k:왼쪽으로, l:오른쪽으로, i: 위로, j:아래로)
char backhome[MSIZE_COL][MSIZE_ROW] = {
	{ '0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0' },
	{ '0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','0' },
	{ '0','1','l','l','l','l','l','j','k','k','l','l','l','j','1','1','j','k','k','k','l','l','j','k','k','k','k','k','1','0' },
	{ '0','1','j','1','1','1','1','j','1','1','1','1','1','j','1','1','j','1','1','1','1','1','j','1','1','1','1','j','1','0' },
	{ '0','1','j','1','0','0','1','j','1','0','0','0','1','j','1','1','j','1','0','0','0','1','j','1','0','0','1','j','1','0' },
	{ '0','1','j','1','1','1','1','j','1','1','1','1','1','j','1','1','j','1','1','1','1','1','j','1','1','1','1','j','1','0' },
	{ '0','1','l','l','l','l','l','j','l','l','j','k','k','k','k','l','l','l','l','j','k','k','j','k','k','k','k','k','1','0' },
	{ '0','1','i','1','1','1','1','j','1','1','j','1','1','1','1','1','1','1','1','j','1','1','j','1','1','1','1','i','1','0' },
	{ '0','1','i','1','1','1','1','j','1','1','j','1','1','1','1','1','1','1','1','j','1','1','j','1','1','1','1','i','1','0' },
	{ '0','1','l','l','l','l','l','j','1','1','l','l','l','j','1','1','j','k','k','k','1','1','j','k','k','k','k','k','1','0' },
	{ '0','1','1','1','1','1','1','j','1','1','1','1','1','j','1','1','j','1','1','1','1','1','j','1','1','1','1','1','1','0' },
	{ '0','0','0','0','0','0','1','j','1','1','1','1','1','j','1','1','j','1','1','1','1','1','j','1','0','0','0','0','0','0' },
	{ '0','0','0','0','0','0','1','j','1','1','l','l','l','l','j','j','k','k','k','k','1','1','j','1','0','0','0','0','0','0' },
	{ '0','0','0','0','0','0','1','j','1','1','i','1','1','1','j','j','1','1','1','i','1','1','j','1','0','0','0','0','0','0' },
	{ '1','1','1','1','1','1','1','j','1','1','i','1','0','0','j','j','0','0','1','i','1','1','j','1','1','1','1','1','1','1' },
	{ 'l','l','l','l','l','l','l','l','l','l','i','1','0','0','2','2','0','0','1','i','k','k','k','k','k','k','k','k','k','k' },
	{ '1','1','1','1','1','1','1','i','1','1','i','1','0','0','0','0','0','0','1','i','1','1','i','1','1','1','1','1','1','1' },
	{ '0','0','0','0','0','0','1','i','1','1','i','1','1','1','1','1','1','1','1','i','1','1','i','1','0','0','0','0','0','0' },
	{ '0','0','0','0','0','0','1','i','1','1','i','k','k','k','k','l','l','l','l','i','1','1','i','1','0','0','0','0','0','0' },
	{ '0','0','0','0','0','0','1','i','1','1','i','1','1','1','1','1','1','1','1','i','1','1','i','1','0','0','0','0','0','0' },
	{ '0','1','1','1','1','1','1','i','1','1','i','1','1','1','1','1','1','1','1','i','1','1','i','1','1','1','1','1','1','0' },
	{ '0','1','l','l','l','l','l','i','l','l','i','k','k','k','1','1','l','l','l','i','k','k','i','k','k','k','k','k','1','0' },
	{ '0','1','i','1','1','1','1','i','1','1','1','1','1','i','1','1','i','1','1','1','1','1','i','1','1','1','1','i','1','0' },
	{ '0','1','i','1','1','1','1','i','1','1','1','1','1','i','1','1','i','1','1','1','1','1','i','1','1','1','1','i','1','0' },
	{ '0','1','i','k','k','1','1','i','k','k','k','l','l','i','k','l','i','k','k','l','l','l','i','1','1','l','l','i','1','0' },
	{ '0','1','1','1','i','1','1','i','1','1','i','1','1','1','1','1','1','1','1','i','1','1','i','1','1','i','1','1','1','0' },
	{ '0','1','1','1','i','1','1','i','1','1','i','1','1','1','1','1','1','1','1','i','1','1','i','1','1','i','1','1','1','0' },
	{ '0','1','l','l','l','l','l','i','1','1','i','k','k','k','1','1','l','l','l','i','1','1','i','k','k','k','k','k','1','0' },
	{ '0','1','i','1','1','1','1','1','1','1','1','1','1','i','1','1','i','1','1','1','1','1','1','1','1','1','1','i','1','0' },
	{ '0','1','i','1','1','1','1','1','1','1','1','1','1','i','1','1','i','1','1','1','1','1','1','1','1','1','1','i','1','0' },
	{ '0','1','i','k','l','l','l','l','l','l','l','l','l','i','k','l','i','k','k','k','k','k','k','k','k','k','l','i','1','0' },
	{ '0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','0' }
};

// 도트 이미지 배열(메인화면 애니메이션 - 왼쪽으로 이동하는 팩맨 1/2프레임)
char rightghost1[14][14] = {
	{ '0','0','0','0','0','1','1','1','1','0','0','0','0','0' },
	{ '0','0','0','1','1','1','1','1','1','1','1','0','0','0' },
	{ '0','0','1','1','1','1','1','1','1','1','1','1','0','0' },
	{ '0','1','1','1','2','2','1','1','1','1','2','2','1','0' },
	{ '0','1','1','2','2','2','2','1','1','2','2','2','2','0' },
	{ '1','1','1','2','2','3','3','1','1','2','2','3','3','0' },
	{ '1','1','1','2','2','3','3','1','1','2','2','3','3','1' },
	{ '1','1','1','1','2','2','1','1','1','1','2','2','1','1' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','1','1' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','1','1' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','1','1' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','1','1' },
	{ '1','1','0','1','1','0','0','1','1','1','1','0','1','1' },
	{ '1','0','0','0','1','0','0','1','1','1','0','0','0','1' }
};

// 도트 이미지 배열(메인화면 애니메이션 - 왼쪽으로 이동하는 팩맨 2/2프레임)
char rightghost2[14][14] = {
	{ '0','0','0','0','0','1','1','1','1','0','0','0','0','0' },
	{ '0','0','0','1','1','1','1','1','1','1','1','0','0','0' },
	{ '0','0','1','1','1','1','1','1','1','1','1','1','0','0' },
	{ '0','1','1','1','2','2','1','1','1','1','2','2','1','0' },
	{ '0','1','1','2','2','2','2','1','1','2','2','2','2','0' },
	{ '1','1','1','2','2','3','3','1','1','2','2','3','3','0' },
	{ '1','1','1','2','2','3','3','1','1','2','2','3','3','1' },
	{ '1','1','1','1','2','2','1','1','1','1','2','2','1','1' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','1','1' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','1','1' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','1','1' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','1','1' },
	{ '1','1','1','1','0','1','1','1','1','0','1','1','1','1' },
	{ '0','1','1','0','0','0','1','1','0','0','0','1','1','0' }
};

// 도트 이미지 배열(메인화면 애니메이션 - 주눅든 유령 1/2프레임)
char timidghost1[14][14] = {
	{ '0','0','0','0','0','1','1','1','1','0','0','0','0','0' },
	{ '0','0','0','1','1','1','1','1','1','1','1','0','0','0' },
	{ '0','0','1','1','1','1','1','1','1','1','1','1','0','0' },
	{ '0','1','1','1','1','1','1','1','1','1','1','1','1','0' },
	{ '0','1','1','1','1','1','1','1','1','1','1','1','1','0' },
	{ '0','1','1','1','2','2','1','1','2','2','1','1','1','0' },
	{ '1','1','1','1','2','2','1','1','2','2','1','1','1','1' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','1','1' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','1','1' },
	{ '1','1','2','2','1','1','2','2','1','1','2','2','1','1' },
	{ '1','2','1','1','2','2','1','1','2','2','1','1','2','1' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','1','1' },
	{ '1','1','1','1','0','1','1','1','1','0','1','1','1','1' },
	{ '0','1','1','0','0','0','1','1','0','0','0','1','1','0' }
};

// 도트 이미지 배열(메인화면 애니메이션 - 주눅든 유령 2/2프레임)
char timidghost2[14][14] = {
	{ '0','0','0','0','0','1','1','1','1','0','0','0','0','0' },
	{ '0','0','0','1','1','1','1','1','1','1','1','0','0','0' },
	{ '0','0','1','1','1','1','1','1','1','1','1','1','0','0' },
	{ '0','1','1','1','1','1','1','1','1','1','1','1','1','0' },
	{ '0','1','1','1','1','1','1','1','1','1','1','1','1','0' },
	{ '0','1','1','1','2','2','1','1','2','2','1','1','1','0' },
	{ '1','1','1','1','2','2','1','1','2','2','1','1','1','1' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','1','1' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','1','1' },
	{ '1','1','2','2','1','1','2','2','1','1','2','2','1','1' },
	{ '1','2','1','1','2','2','1','1','2','2','1','1','2','1' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','1','1' },
	{ '1','1','0','0','1','1','0','0','1','1','1','0','1','1' },
	{ '1','0','0','0','1','1','0','0','1','1','0','0','0','1' }
};

// 도트 이미지 배열(메인화면 애니메이션 - 왼쪽으로 이동하는 팩맨 1/2프레임)
char leftpacman1[14][13] = {
	{ '0','0','0','1','1','1','1','1','1','0','0','0','0' },
	{ '0','1','1','1','1','1','1','1','1','1','1','0','0' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','0' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','0' },
	{ '0','1','1','1','1','1','1','1','1','1','1','1','1' },
	{ '0','0','0','1','1','1','1','1','1','1','1','1','1' },
	{ '0','0','0','0','0','0','1','1','1','1','1','1','1' },
	{ '0','0','0','0','0','0','0','1','1','1','1','1','1' },
	{ '0','0','0','0','0','0','1','1','1','1','1','1','1' },
	{ '0','0','1','1','1','1','1','1','1','1','1','1','1' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','0' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','0' },
	{ '0','1','1','1','1','1','1','1','1','1','1','0','0' },
	{ '0','0','0','1','1','1','1','1','1','0','0','0','0' }
};

// 도트 이미지 배열(메인화면 애니메이션 - 왼쪽으로 이동하는 팩맨 2/2프레임)
char leftpacman2[14][13] = {
	{ '0','0','0','0','1','1','1','1','1','0','0','0','0' },
	{ '0','0','1','1','1','1','1','1','1','1','1','0','0' },
	{ '0','1','1','1','1','1','1','1','1','1','1','1','0' },
	{ '0','1','1','1','1','1','1','1','1','1','1','1','0' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','1' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','1' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','1' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','1' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','1' },
	{ '1','1','1','1','1','1','1','1','1','1','1','1','1' },
	{ '0','1','1','1','1','1','1','1','1','1','1','1','0' },
	{ '0','1','1','1','1','1','1','1','1','1','1','1','0' },
	{ '0','0','1','1','1','1','1','1','1','1','1','0','0' },
	{ '0','0','0','0','1','1','1','1','1','0','0','0','0' }
};

// 도트 이미지 배열("RANK"문자열)
char Rankch[5][19] = {
	{ '1','1','1','0','0','0','1','1','0','0','1','1','1','0','0','1','0','0','1' },
	{ '1','0','0','1','0','1','0','0','1','0','1','0','0','1','0','1','0','1','0' },
	{ '1','1','1','1','0','1','1','1','1','0','1','0','0','1','0','1','1','0','0' },
	{ '1','0','1','0','0','1','0','0','1','0','1','0','0','1','0','1','0','1','0' },
	{ '1','0','0','1','0','1','0','0','1','0','1','0','0','1','0','1','0','0','1' }
};

// 도트 이미지 배열("HELP"문자열)
char Helpch[5][19] = {
	{ '1','0','0','1','0','1','1','1','1','0','1','0','0','0','0','1','1','1','0' },
	{ '1','0','0','1','0','1','0','0','0','0','1','0','0','0','0','1','0','0','1' },
	{ '1','1','1','1','0','1','1','1','1','0','1','0','0','0','0','1','1','1','0' },
	{ '1','0','0','1','0','1','0','0','0','0','1','0','0','0','0','1','0','0','0' },
	{ '1','0','0','1','0','1','1','1','1','0','1','1','1','1','0','1','0','0','0' }
};

// 도트 이미지(랭킹 메달)
char Medal[8][7] = {
	{ '2','3','0','0','0','3','2' },
	{ '0','2','3','0','3','2','0' },
	{ '0','2','3','0','3','2','0' },
	{ '0','0','1','1','1','0','0' },
	{ '0','1','4','4','1','1','0' },
	{ '0','1','4','1','1','1','0' },
	{ '0','1','1','1','1','1','0' },
	{ '0','0','1','1','1','0','0' }
};

// 함수선언
void printMap(char m[MSIZE_COL][MSIZE_ROW]);
void drawbox();
void erasestar(int x, int y);
void eraseG(int x, int y);
void putpacman1(int x, int y, unsigned char ch);
void putpacman2(int x, int y, unsigned char ch);
void putghost(int n, int x, int y, char status);
void timidghost(int n, int x, int y, char status);
void textcolor(int fg_color, int bg_color);
void gotoxy(int x, int y);
void removeCursor(void);
void cls(int bg_color, int text_color);
void show_dir(char d);
char Set_Dir(char dir, int x, int y);
int PacmanDie(int x, int y, int n);
void GhostDie(int x, int y);
void showObject(char m[MSIZE_COL][MSIZE_ROW]);
void showItem();
void ghostA(int n, char status);
int TimidTime();
int singleMode();
void cooperationMode();
void battleMode();
void initGhost();
void printState();
void animateReadyStart();
int pacman1(unsigned char ch);
int pacman2(unsigned char ch);
void initPacman();
void enqueue_dir(int n, char ch);
void dir_insert_next(char ch);
char peekNow(int n);
void printLineBox(int x, int y, int w, int h);

#define MAX_SIZE 2
typedef char element;
element dir_Queue1[MAX_SIZE];
element dir_Queue2[MAX_SIZE];
int present = 0, next = 1;

void init_Queue()
{
	dir_Queue1[present] = dir_Queue1[next] = NULL;
	dir_Queue2[present] = dir_Queue2[next] = NULL;
}
void enqueue_dir(int n, char ch)
{
	char peek = peekNow(n);

	if (ch == peek)	return; // (현재방향 == 입력방향) PASS!
	else { // (현재방향 != 입력방향)
		if (n == 0) { // 팩맨 1의 방향저장
			if (peek == UP) { // 현재 위으로 가고있고
				if (ch == DOWN)	dir_Queue1[present] = ch;	// 진행방향 반대라면 prsent에 삽입
				else			dir_Queue1[next] = ch;		// 진행방향 옆이라면 next에 삽입
			}
			else if (peek == DOWN) { // 현재 아래로 가고있고
				if (ch == UP)	dir_Queue1[present] = ch; // 반대
				else			dir_Queue1[next] = ch; // 옆
			}
			else if (peek == LEFT) { // 현재 왼쪽으로 가고있고
				if (ch == RIGHT)	dir_Queue1[present] = ch; // 반대
				else			dir_Queue1[next] = ch; // 옆
			}
			else if (peek == RIGHT) { // 현재 오른쪽으로 가고있고
				if (ch == LEFT)	dir_Queue1[present] = ch; // 반대
				else			dir_Queue1[next] = ch; // 옆
			}
		}
		else if (n == 1) { // 팩맨 2의 방향저장
			if (peek == UP2) { // 현재 위으로 가고있고
				dir_Queue2[present] = ch;
				if (ch == DOWN2)	dir_Queue2[present] = ch;	// 진행방향 반대라면 prsent에 삽입
				else			dir_Queue2[next] = ch;		// 진행방향 옆이라면 next에 삽입
			}
			else if (peek == DOWN2) { // 현재 아래로 가고있고
				if (ch == UP2)	dir_Queue2[present] = ch; // 반대
				else			dir_Queue1[next] = ch; // 옆
			}
			else if (peek == LEFT2) { // 현재 왼쪽으로 가고있고
				if (ch == RIGHT)	dir_Queue2[present] = ch; // 반대
				else			dir_Queue2[next] = ch; // 옆
			}
			else if (peek == RIGHT) { // 현재 오른쪽으로 가고있고
				if (ch == LEFT2)	dir_Queue2[present] = ch; // 반대
				else			dir_Queue2[next] = ch; // 옆
			}
		}
	}
}

char peekNow(int n)
{
	return (n == 0 ? dir_Queue1[present] : dir_Queue2[present]);
}
char peekNext(int n)
{
	return (n == 0 ? dir_Queue1[next] : dir_Queue2[next]);
}

int replace_dir(int n, int x, int y)
{
	// 진행(하려고 하는) 방향이 막혀있다면, 방향전환을 하지 말 것.
	if (((peekNext(n) == UP || peekNext(n) == UP2) && map1[y - 1][x / 2] == '1') ||
		((peekNext(n) == DOWN || peekNext(n) == DOWN2) && map1[y + 1][x / 2] == '1') ||
		((peekNext(n) == LEFT || peekNext(n) == LEFT2) && map1[y][x / 2 - 1] == '1') ||
		((peekNext(n) == RIGHT || peekNext(n) == RIGHT2) && map1[y][x / 2 + 1] == '1'))
		return 0; 
	else {
		if (n == 0) {
			dir_Queue1[present] = dir_Queue1[next];
			return 1;
		}
		else if (n == 1) {
			dir_Queue2[present] = dir_Queue2[next];
			return 1;
		}
	}
}

void initObject()
{
	int r, c;
	for (r = 0; r < MSIZE_ROW + 1; r++)
		for (c = 0; c < MSIZE_COL; c++)
			object[r][c] = OBJECT[r][c];
}
void removeCursor(void)  // 커서를 안보이게 한다
{
	CONSOLE_CURSOR_INFO curInfo;
	GetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &curInfo);
	curInfo.bVisible = 0;
	SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &curInfo);
}

void gotoxy(int x, int y) //내가 원하는 위치로 커서 이동
{
	COORD pos = { x, y };
	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos);
}

void textcolor(int fg_color, int bg_color)
{
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), fg_color | bg_color << 4);
}

// 1p 팩맨 알고리즘 출력
void putpacman1(int x, int y, unsigned char ch)
{
	gotoxy(x, y); // 커서 이동
	textcolor(YELLOW2, BLACK);// 색 설정

	// 입을 뻥끗 거리는 모션을 구현하기 위해 두 프레임으로 구성
	if (spark1 == 0) { // 프레임1
		if (p[0].status == LIVE || p[0].status == IMMORTAL) {
			if (p[0].status == IMMORTAL)
				textcolor(RED1, BLACK);
			printf("●");
		}
		else if (p[0].status == DIE) {
			textcolor(GRAY2, BLACK);
			printf("†");
		}
		spark1 = 1; // 전환
	}
	else { // 프레임2 
		if (p[0].status == LIVE || p[0].status == IMMORTAL) {
			if (p[0].status == IMMORTAL && ImmortalTime(0) > 3000)
				textcolor(RED1, BLACK);
			if (ch == UP)
				printf("∨");
			else if (ch == DOWN)
				printf("∧");
			else if (ch == RIGHT)
				printf("＜");
			else if (ch == LEFT)
				printf("＞");
			else
				printf("●");
		}
		else if (p[0].status == DIE) {
			textcolor(GRAY2, BLACK);
			printf("‡");
		}
		spark1 = 0; // 전환
	}
}

// 2p 팩맨 알고리즘 출력
void putpacman2(int x, int y, unsigned char ch)
{
	gotoxy(x, y); // 커서 이동
	textcolor(GREEN2, BLACK); // 색 설정

	 // 입을 뻥끗 거리는 모션을 구현하기 위해 두 프레임으로 구성
	if (spark2 == 0) { // 프레임1
		if (p[1].status == LIVE || p[1].status == IMMORTAL) {
			if (p[1].status == IMMORTAL)
				textcolor(RED1, BLACK);
			printf("●");
		}
		else if (p[1].status == DIE) {
			textcolor(GRAY2, BLACK);
			printf("†");
		}
		spark2 = 1; // 전환
	}
	else { // 프레임2
		if (p[1].status == LIVE || p[1].status == IMMORTAL) {
			if (p[1].status == IMMORTAL && ImmortalTime(1) > 3000)
				textcolor(RED1, BLACK);
			if (ch == UP)
				printf("∨");
			else if (ch == DOWN)
				printf("∧");
			else if (ch == RIGHT)
				printf("＜");
			else if (ch == LEFT)
				printf("＞");
			else
				printf("●");
		}
		else if (p[1].status == DIE) {
			textcolor(GRAY2, BLACK);
			printf("‡");
		}
		spark2 = 0; // 전환
	}
}

void putghost(int n, int x, int y, char status)
{
	gotoxy(x, y); // 커서 이동

	// 개체, 상태에 따라 색과 모양이 다름
	if (g[n].status == DIE) { // 상태: 죽음
		textcolor(WHITE, BLACK);
		printf("∞");
	}
	else { // 상태: 살아있음
		if (g[n].timid == 1) { // 상태: 살아있지만 주눅듬(도망감)
			if (rem_t >= 3000) {
				textcolor(CYAN1, BLACK);
				printf("@@");
			}
			else {
				// 애니메이션
				if (spark1 == 0) { // 1프레임
					textcolor(CYAN1, BLACK);
					printf("@");
					textcolor(WHITE, BLACK);
					printf("@");
				}
				else { // 2프레임
					textcolor(WHITE, BLACK);
					printf("@");
					textcolor(CYAN1, BLACK);
					printf("@");
				}
			}
		}
		else { // 개체에 따라 색 설정
			if (n == 0)
				textcolor(RED1, BLACK);
			else if (n == 1)
				textcolor(MAGENTA2, BLACK);
			else if (n == 2)
				textcolor(CYAN2, BLACK);
			else if (n == 3)
				textcolor(YELLOW1, BLACK);
			else
				textcolor(GRAY2, BLACK);
			printf("▦");
		}
	}
}

void eraseG(int x, int y)
{
	gotoxy(x, y);
	textcolor(WHITE, BLACK);
	if (object[y][x / 2] == '1')
		printf("·");
	else if (object[y][x / 2] == '2')
		printf("×");
	else
		printf("  ");
}

void erasestar(int x, int y)
{
	gotoxy(x, y);
	textcolor(BLACK, BLACK);
	printf("  ");
}

void cls(int bg_color, int text_color)
{
	char cmd[100];
	system("cls");
	sprintf(cmd, "COLOR %x%x", bg_color, text_color);
	system(cmd);
}

void drawbox()
{
	int i, j;
	textcolor(WHITE, BLACK);
	gotoxy(0, 0);
	printf("┏");
	gotoxy(0, 32);
	printf("┗");
	gotoxy(58, 32);
	printf("┛");
	gotoxy(58, 0);
	printf("┓");

	for (i = 2; i < 57; i += 2) {
		gotoxy(i, 0);
		printf("━");
		gotoxy(i, 32);
		printf("━");
	}
	for (i = 1; i < 32; i++) {
		gotoxy(0, i);
		printf("┃");
		gotoxy(58, i);
		printf("┃");
	}
}

void printInGameStatus()
{
	int i;
	// textcolor(BLACK, WHITE);
	textcolor(WHITE, BLACK);
	/*gotoxy(60, 2); printf("                 ");
	gotoxy(60, 3); printf("                 ");
	gotoxy(60, 4); printf("                 ");
	gotoxy(60, 5); printf("                 ");*/
	printLineBox(60, 4, 7, 1);
	gotoxy(62, 3); printf("> SCORE");
	gotoxy(62, 5); printf("%6d", score);
	//textcolor(WHITE, BLACK);

	// gotoxy(60, 10); printf("      "); // 팩맨1의 라이프 수 표시 
	printLineBox(60, 10, 7, 1);
	gotoxy(62, 9); printf("> LIFE");
	gotoxy(62, 11); printf(": ");
	gotoxy(64, 11);
	for (i = 0; i < life1 - 1; i++) {
		textcolor(YELLOW2, BLACK);
		printf("●");
	}
	if (mode != SINGLE) {
		gotoxy(60, 12); printf("      "); // 팩맨2의 라이프 수 표시
		gotoxy(60, 12);
		for (i = 0; i < life2 - 1; i++) {
			textcolor(GREEN2, BLACK);
			printf("●");
		}
	}

	/*gotoxy(60, 22); textcolor(RED2, YELLOW2); printf("DEBUG INFORMATION");
	textcolor(WHITE, BLACK);
	gotoxy(60, 23); show_dir(dir_Queue1[present]); printf("	present");
	gotoxy(60, 24); show_dir(dir_Queue1[next]); printf("	next");

	gotoxy(60, 26); printf("pacman1 : %c", p[0].status);
	gotoxy(60, 27); printf("pacman2 : %c", p[1].status);
	gotoxy(60, 29); printf("remain coin: %3d", coin);*/
}
int plusScore()
{
	int plus[GHOST + 2] = { 100,200,400,1600,3200,6800 };
	score += plus[cnt];
	return plus[cnt++];
}

void dieEffect(int x, int y)
{
	erasestar(x, y);
	textcolor(WHITE, BLACK);
	gotoxy(x, y);
	printf("◎");
	Sleep(400);
	gotoxy(x, y);
	printf("○");
	Sleep(300);
	gotoxy(x, y);
	printf("⊙");
	Sleep(200);
	gotoxy(x, y);
	printf("※");
	Sleep(200);
	gotoxy(x, y);
	printf("＋");
	Sleep(2000);
}
void printGameOverText()
{
	gotoxy(30, 20); printf("GAME OVER");
	Sleep(300);
}
void Stuck()
{

}

int PacmanDie(int x, int y, int n)
{
	int i;
	for (i = 0; i < GHOST; i++) { // 팩맨 무적, 유령 귀환중(∞), 주눅모드(@@)일때 죽지않음
		if (g[i].status == DIE || g[i].timid == 1 || p[n].status == IMMORTAL)
			return 0; // 게임 계속
		else if (p[n].status == LIVE && (x == g[i].nx && y == g[i].ny || x == g[i].tx && y == g[i].ty)) { // 그 외(▦)에는 닿으면 죽음
			if (n == 0)	life1--;
			else		life2--; // 라이프 차감
			if ((mode == SINGLE && life1 <= 0) || (life1 == 0 && life2 <= 0)) { // 라이프가 0이면
				printGameOverText();
				return 2; // 게임 오버
			}
			if (mode == SINGLE) {
				dieEffect(x, y); // 사라지는 이펙트
				return 1;
			}
			else { // 협동, 배틀모드라면
				p[n].status = DIE; // 팩맨 죽음
				p[n].direction = 0; // 위치 고정
				C[n] = 0; // 제어권 강탈
				if (n == 0) {
					start = clock();
					DieTime(n);
				}
				else {
					DieTime(n);
					start2 = clock();
				}
				return 0; // 게임 계속
			}

		}

	}
}
void GhostDie(int x, int y)
{
	int i;
	for (i = 0; i < GHOST; i++) { // 주눅모드의 유령이 팩맨과 닿는다면
		if (g[i].timid == 1 && (x == g[i].nx && y == g[i].ny || x == g[i].tx && y == g[i].ty)) {
			g[i].status = DIE; // 상태는 '죽음'으로 변경
			g[i].timid = 0; // 주눅모드는 해제
			gotoxy(x, y); textcolor(WHITE, BLACK);
			printf("%d", plusScore()); // 유령이 죽은 자리에 점수 출력
			if (mode == SINGLE)
				Sleep(500);
			gotoxy(x, y);
			printf("    ");
			printMap(map1); // 점수출력으로 지워진 맵 재출력
		}
	}
}

int TimidTime()
{
	present_time = clock() - start;
	rem_t = 1000 * 8 - present_time; // 주눅모드는 8초
	return rem_t;
}
int ImmortalTime(int n)
{
	if (n == 0) {
		present_time = clock() - start;
		rem_t = 1000 * 8 - present_time;
		return rem_t;
	}
	else {
		present_time2 = clock() - start2;
		rem_t2 = 1000 * 8 - present_time2; // 무적모드는 8초
		return rem_t2;
	}
}

int DieTime(int n)
{
	if (n == 0) {
		present_time = clock() - start;
		rem_t = 1000 * 8 - present_time;
		return rem_t;
	}
	else {
		present_time2 = clock() - start2;
		rem_t2 = 1000 * 8 - present_time2; // 무적모드는 8초
		return rem_t2;
	}
}

void ClearEffect() // 스테이지 클리어 이펙트, 깜빡깜빡
{
	int r, c, i, j;
	Sleep(1000);
	for (i = 0; i < 4; i++) {
		for (r = 1; r < MSIZE_ROW - 1; r++) {
			for (c = 0; c < MSIZE_COL; c++) {
				if (map1[c][r] == '1') {
					gotoxy((r * 2), c);
					if (i % 2)
						textcolor(BLUE2, BLUE1);
					else
						textcolor(GRAY2, WHITE);
					printf("┬");
				}
			}
			printf("\n");
		}
		Sleep(500);
	}
}

void initGame()
{
	stage = 0; // 스테이지 초기화
	score = 0; // 점수 초기화
	coin = 256; // 코인 수 초기화
	life1 = 3;
	life2 = 3;
	init_Queue();
}

int nextStage()
{
	stage++; // 다음 스테이지로
	if (stage == 1) { // 마지막 스테이지라면
		textcolor(WHITE, BLACK);
		gotoxy(23, 15); printf("STAGE ALL CLEAR");
		Sleep(2000);
		return 0; // 게임 끝, 메인메뉴로
	}
	initGame();
	init_Queue();
	coin = 256; // 코인 수 초기화

				// 모두 제정렬!
	initGhost();
	initObject();
	printState();
	animateReadyStart();
	pacman1(0);
	if (mode != SINGLE)
		pacman2(0);
	return 1; // 게임 계속
}

void initPacman()
{
	p[0].ox = p[0].nx = 30;
	p[0].oy = p[0].ny = 24;
	p[1].ox = p[1].nx = 28;
	p[1].oy = p[1].ny = 24;
	p[0].direction = p[1].direction = 0;
	p[0].status = p[1].status = LIVE;
}

int pacman1(unsigned char ch) // 팩맨1
{
	int i;
	static int move_flag = 1;
	static int called = 0;
	// 해당 좌표에 팩맨 그리기
	if (called == 0) {
		removeCursor();
		putpacman1(p[0].ox, p[0].oy, ch);
		called = 1;
	}
	// 한 방향으로 계속 자동이동
	if (keep_moving && ch == 0)
		ch = p[0].direction;
	p[0].direction = ch;

	// 스피드 조절
	if (count1 < speed1) {
		count1 += Delay;
		return;
	} 
	else {
		count1 = 0;
	}

	switch (ch) {
	// 기본 이동
	case UP:
		if (p[0].oy > 0 && map1[p[0].oy - 1][p[0].ox / 2] != '1')
			p[0].ny = p[0].oy - 1;
		move_flag = 1;
		break;
	case DOWN:
		if (p[0].oy < HEIGHT - 1 && map1[p[0].oy + 1][p[0].ox / 2] != '1')
			p[0].ny = p[0].oy + 1;
		move_flag = 1;
		break;
	case LEFT:
		if (p[0].ox > 0 && map1[p[0].oy][p[0].ox / 2 - 1] != '1')
			p[0].nx = p[0].ox - 2;
		move_flag = 1;
		break;
	case RIGHT:
		if (p[0].ox < WIDTH - 2 && map1[p[0].oy][p[0].ox / 2 + 1] != '1')
			p[0].nx = p[0].ox + 2;
		move_flag = 1;
		break;
	case 0:
		break;
	}

	// 터널 반대편 이동
	if (p[0].nx == 58 && p[0].ny == 15)
		p[0].nx = 2;
	if (p[0].nx == 0 && p[0].ny == 15)
		p[0].nx = 56;

	// 현재 위치에서의 이벤트(점수 증가, 클리어 조건)
	if (move_flag) {
		erasestar(p[0].ox, p[0].oy);
		if (object[p[0].oy][p[0].ox / 2] != '0') {
			object[p[0].oy][p[0].ox / 2] = '0';
			coin--;
			score += 10;
			printInGameStatus();
			if (coin == 0) { // 스테이지 클리어
				ClearEffect();
				initPacman();
				ch = p[0].direction = 0;
				if (nextStage() == 0) { // 다음스테이지가 없다면
					return 0; // 종료 후 메인메뉴
				}
			}
		}
		putpacman1(p[0].nx, p[0].ny, ch);
		p[0].ox = p[0].nx; // 마지막 위치를 기억한다.
		p[0].oy = p[0].ny;
	}

	if (object[p[0].ny][p[0].nx / 2] == '2') { // (아이템을 먹는다면)
		start = clock(); // 아이템 효과 기준시간
		if (mode == SINGLE) { // 싱글모드라면,
			for (i = 0; i < GHOST; i++)
				g[i].timid = 1; // 유령들은 잠시 주눅모드 
		}
		else  // 협동, 배틀모드라면,
			p[0].status = IMMORTAL; //팩맨이 잠시 무적
	}

	if (mode == SINGLE) { // 싱글모드라면,
		if (TimidTime() < 0) { // 주눅모드 제한시간이 끝날시
			for (i = 0; i < GHOST; i++)
				g[i].timid = 0; // 주눅모드 해제
			cnt = 0; // 포식횟수 초기화
		}
	}

	else { // 협동, 배틀모드라면,
		if (ImmortalTime(0) < 0 && (p[0].status == IMMORTAL))
			p[0].status = LIVE; // 무적모드 해제
	}
	if (DieTime(0) < 0) {
		start = clock();
		p[0].status = LIVE;
		C[0] = 1;
	}
	if (PacmanDie(p[0].nx, p[0].ny, 0) == 1) { // 팩맨이 죽는다면,
		erasestar(p[0].nx, p[0].ny);
		initGhost(); // 유령 제자리로
		initPacman(); // 팩맨 제자리로
		printState(); // 현상태 출력
		animateReadyStart(); // 준비....시작!
		init_Queue();
	}
	else if (PacmanDie(p[0].nx, p[0].ny, 0) == 2) // 라이프가 0라면,
		return 0; // 게임 끝, 메뉴로

	GhostDie(p[0].nx, p[0].ny);
	return 1; // 게임 계속
}

int pacman2(unsigned char ch)
{
	int i;
	static int move_flag = 1;
	static int called = 0;
	if (called == 0) {
		removeCursor();
		putpacman2(p[1].ox, p[1].oy, ch);
		called = 1;
	}
	if (keep_moving && ch == 0)
		ch = p[1].direction;
	p[1].direction = ch;
	switch (ch) {
	case UP2:
		if (p[1].oy > 0 && map1[p[1].oy - 1][p[1].ox / 2] != '1')
			p[1].ny = p[1].oy - 1;
		move_flag = 1;
		break;
	case DOWN2:
		if (p[1].oy < HEIGHT - 1 && map1[p[1].oy + 1][p[1].ox / 2] != '1')
			p[1].ny = p[1].oy + 1;
		move_flag = 1;
		break;
	case LEFT2:
		if (p[1].ox > 0 && map1[p[1].oy][p[1].ox / 2 - 1] != '1')
			p[1].nx = p[1].ox - 2;
		move_flag = 1;
		break;
	case RIGHT2:
		if (p[1].ox < WIDTH - 2 && map1[p[1].oy][p[1].ox / 2 + 1] != '1')
			p[1].nx = p[1].ox + 2;
		move_flag = 1;
		break;
	case 0:
		break;
	}
	// 터널 이동
	if (p[1].nx == 58 && p[1].ny == 15)
		p[1].nx = 2;
	if (p[1].nx == 0 && p[1].ny == 15)
		p[1].nx = 56;

	if (move_flag) { // 팩맨 출력
		erasestar(p[1].ox, p[1].oy);
		if (object[p[1].oy][p[1].ox / 2] != '0') {
			object[p[1].oy][p[1].ox / 2] = '0';
			coin--;
			score += 10;
			printInGameStatus();
			if (coin == 0) { // 스테이지 클리어
				ClearEffect();
				initPacman();
				ch = p[1].direction = 0;
				if (nextStage() == 0) // 다음스테이지가 없다면
					return 0; // 종료 후 메인메뉴
			}
		}
		putpacman2(p[1].nx, p[1].ny, ch);
		p[1].ox = p[1].nx; // 마지막 위치를 기억한다.
		p[1].oy = p[1].ny;
	}

	if (object[p[1].ny][p[1].nx / 2] == '2') { // (아이템을 먹는다면)
		start = clock(); // 아이템 효과 기준시간
		if (mode == SINGLE) { // 싱글모드라면,
			for (i = 0; i < GHOST; i++)
				g[i].timid = 1; // 유령들은 잠시 주눅모드 
		}
		else  // 협동, 배틀모드라면,
			p[1].status = IMMORTAL; //팩맨이 잠시 무적
	}

	if (mode == SINGLE) { // 싱글모드라면,
		if (TimidTime() < 0) { // 주눅모드 제한시간이 끝날시
			for (i = 0; i < GHOST; i++)
				g[i].timid = 0; // 주눅모드 해제
			cnt = 0; // 포식횟수 초기화
					 //speed1 = 150;
		}
		//else speed1 = 0;
	}
	else { // 협동, 배틀모드라면,
		if (ImmortalTime(1) < 0 && (p[1].status == IMMORTAL))
			p[1].status = LIVE; // 무적모드 해제
	}

	if (DieTime(1) < 0) {
		start = clock();
		p[1].status = LIVE;
		C[1] = 1;
	}

	if (PacmanDie(p[1].nx, p[1].ny, 1) == 1) { // 팩맨이 죽는다면,
		erasestar(p[1].nx, p[1].ny);
		initGhost(); // 유령 제자리로
		initPacman(); // 팩맨 제자리로
		printState(); // 현상태 출력
		animateReadyStart(); // 준비....시작!
	}
	else if (PacmanDie(p[1].nx, p[1].ny, 1) == 2) // 라이프가 0라면,
		return 0; // 게임 끝, 메뉴로

	GhostDie(p[1].nx, p[1].ny);
	return 1; // 게임 계속
}

char Set_Dir(char dir, int x, int y)
{
	int r;
	char flag = map1[y][x / 2];

	if (x == 28 && y == 12)
		return GLEFT;
	if (x == 30 && y == 12)
		return GRIGHT;
	switch (flag) {
	case '2': // 외길이라면...
		if (map1[y - 1][x / 2] == '0' && dir != GDOWN)
			return GUP;
		else if (map1[y + 1][x / 2] == '0' && dir != GUP)
			return GDOWN;
		else if (map1[y][(x / 2) - 1] == '0' && dir != GRIGHT)
			return GLEFT;
		else if (map1[y][(x / 2) + 1] == '0' && dir != GLEFT)
			return GRIGHT;
		break;
	case '3': // 두 갈래길이라면...
		r = rand() & 2;
		if ((dir == GUP&&map1[y][(x / 2) + 1] == '1') || (dir == GLEFT&&map1[y + 1][x / 2] == '1')) { // 상중우막, 좌중하막
			if (r == 0)	return GUP;
			else		return GLEFT;
		}
		else if ((dir == GUP&&map1[y][(x / 2) - 1] == '1') || (dir == GRIGHT&&map1[y + 1][x / 2] == '1')) { // 상중좌막, 우중하막
			if (r == 0)	return GUP;
			else		return GRIGHT;
		}
		else if ((dir == GDOWN&&map1[y][(x / 2) - 1] == '1') || (dir == GRIGHT&&map1[y - 1][x / 2] == '1')) { // 하중좌막, 우중상막
			if (r == 0)	return GDOWN;
			else		return GRIGHT;
		}
		else if ((dir == GLEFT&&map1[y - 1][x / 2] == '1') || (dir == GDOWN&&map1[y][(x / 2) + 1] == '1')) { // 좌중상막, 하중우막
			if (r == 0)	return GDOWN;
			else		return GLEFT;
		}
		else if ((dir == GDOWN&&map1[y + 1][x / 2] == '1') || (dir == GUP&&map1[y - 1][x / 2] == '1')) {// 하중하막, 상중상막
			if (r == 0)	return GRIGHT;
			else		return GLEFT;
		}
		else { // 우중우막, 좌중좌막
			if (r == 0)	return GUP;
			else		return GDOWN;
		}
		break;
	case '4': // 세 갈래길이라면...
		r = rand() % 3;
		if (dir == GUP) {
			if (r == 0)		return GUP;
			else if (r == 1)	return GLEFT;
			else if (r == 2)	return GRIGHT;
		}
		else if (dir == GDOWN) {
			if (r == 0)		return GDOWN;
			else if (r == 1)	return GLEFT;
			else if (r == 2)	return GRIGHT;
		}
		else if (dir == GLEFT) {
			if (r == 0)		return GLEFT;
			else if (r == 1)	return GUP;
			else if (r == 2)	return GDOWN;
		}
		else if (dir == GRIGHT) {
			if (r == 0)		return GRIGHT;
			else if (r == 1)	return GUP;
			else if (r == 2)	return GDOWN;
		}
		break;
	}
}
void show_dir(char d) // 유령 디버깅용 방향표시
{
	if (d == GUP || d == UP)
		printf("↑");
	if (d == GDOWN || d == DOWN)
		printf("↓");
	if (d == GLEFT || d == LEFT)
		printf("←");
	if (d == GRIGHT || d == RIGHT)
		printf("→");
}
void initGhost() // 유령 상태 초기화
{
	int i;
	for (i = 0; i < GHOST; i++) {
		g[i].ox = g[i].nx = 30;
		g[i].oy = g[i].ny = 15;
		g[i].direction = 'i' + i;
		g[i].status = LIVE;
		g[i].timid = 0;
	}
}

void ghostA(int n, char status)
{
	int move_flag = 1;
	static int called = 0;

	if (called == 0) { // 최초 위치
		removeCursor();
		putghost(n, g[n].ox, g[n].oy, g[n].status);
		erasestar(g[n].ox, g[n].oy);
		called = 1;
	}
	// 스피드조절
	if (g[n].timid == 1)			speed2[n] = 300;
	else if (g[n].timid == 0)	speed2[n] = 0;

	if (count2[n] < speed2[n]) {
		count2[n] += Delay;
		return;
	}
	else
		count2[n] = 0;


	switch (g[n].status) {
	case LIVE:
		if (map1[g[n].ny][g[n].nx / 2] != '0') // 갈림길에서의 방향 결정
			g[n].direction = Set_Dir(g[n].direction, g[n].nx, g[n].ny);
		break;
	case DIE:
		g[n].direction = backhome[g[n].ny][g[n].nx / 2];
		if (backhome[g[n].ny][g[n].nx / 2] == '2')
			g[n].status = LIVE;
		break;
	}
	switch (g[n].direction) {
	case GUP:
		if (g[n].oy > 0 && map1[g[n].oy - 1][g[n].ox / 2] != '1')
			g[n].ny = g[n].oy - 1;
		move_flag = 1;
		break;
	case GDOWN:
		if (g[n].oy < HEIGHT - 1 && map1[g[n].oy + 1][g[n].ox / 2] != '1')
			g[n].ny = g[n].oy + 1;
		move_flag = 1;
		break;
	case GLEFT:
		if (g[n].ox > 0 && map1[g[n].oy][g[n].ox / 2 - 1] != '1')
			g[n].nx = g[n].ox - 2;
		move_flag = 1;
		break;
	case GRIGHT:
		if (g[n].ox < WIDTH - 2 && map1[g[n].oy][g[n].ox / 2 + 1] != '1')
			g[n].nx = g[n].ox + 2;
		move_flag = 1;
		break;
	}

	if (g[n].nx == 58 && g[n].ny == 15)
		g[n].nx = 2;
	if (g[n].nx == 0 && g[n].ny == 15)
		g[n].nx = 56;

	g[n].tx = g[n].ox; // 흔적좌표
	g[n].ty = g[n].oy;

	if (move_flag) {
		eraseG(g[n].ox, g[n].oy);
		putghost(n, g[n].nx, g[n].ny, g[n].status);
		g[n].ox = g[n].nx; // 마지막 위치를 기억한다.
		g[n].oy = g[n].ny;
	}
}

void showObject(char m[MSIZE_COL][MSIZE_ROW])
{
	int r, c;
	for (r = 1; r < MSIZE_ROW - 1; r++) {
		for (c = 0; c < MSIZE_COL; c++) {
			if (m[c][r] == '1') {
				gotoxy((r * 2), c);
				textcolor(WHITE, BLACK);
				printf("·");
			}
		}
	}
}

void showItem()
{
	gotoxy(2 * 2, 4);
	textcolor(WHITE, BLACK);
	if (object[4][2] == '2') {
		if (spark1 == 0)
			printf("＋");
		else
			printf("×");
	}
	else
		printf("  ");
	gotoxy(27 * 2, 4);
	if (object[4][27] == '2') {
		if (spark1 == 0)
			printf("＋");
		else
			printf("×");
	}
	else
		printf("  ");
	gotoxy(2 * 2, 24);
	if (object[24][2] == '2') {
		if (spark1 == 0)
			printf("＋");
		else
			printf("×");
	}
	else
		printf("  ");
	gotoxy(27 * 2, 24);
	if (object[24][27] == '2') {
		if (spark1 == 0)
			printf("＋");
		else
			printf("×");
	}
	else
		printf("  ");
}

void printMap(char m[MSIZE_COL][MSIZE_ROW])
{
	int r, c;
	for (r = 1; r < MSIZE_ROW - 1; r++) {
		for (c = 0; c < MSIZE_COL; c++) {
			if (m[c][r] == '1') {
				gotoxy((r * 2), c);
				textcolor(BLUE2, BLUE1);
				printf("┬");
			}
			/*else if(m[c][r] == '0') {
			gotoxy((r*2), c);
			textcolor(BLACK, BLACK);
			printf("  ");
			}*/
		}
		printf("\n");
	}
	printf("\n\n");
}

void printLineBox(int x, int y, int w, int h)
{
	int i, j;
	int bothend[2] = { x,x+w*2+2 };
	gotoxy(x, y); printf("┏");
	for (i = 0; i < w; i++) printf("━");
	printf("┓");

	for (i = 0; i < h; i++) {
		for (j = 0; j < 2; j++) {
			gotoxy(bothend[j], y+1 + i); printf("┃");
		}
	}

	gotoxy(x, y + h+1); printf("┗");
	for (i = 0; i < w; i++) printf("━");
	printf("┛");
}

//void printMenuBox() {
//int i, j, bothend[2] = { 27,49 };
//gotoxy(27, 24); printf("┏━━━━━━━━━━┓");
//for (i = 0; i < 7; i++)
//	for (j = 0; j < 2; j++) {
//		gotoxy(bothend[j], 25 + i); printf("┃");
//	}
//gotoxy(27, 32); printf("┗━━━━━━━━━━┛");
//}

void printPacmanDotImage(int x, int y)
{
	gotoxy(x, y);
	textcolor(BLACK, YELLOW2);
	removeCursor();
	printf("  ");
}

void printGhostDotImage(int x, int y, int color)
{
	gotoxy(x, y);
	textcolor(WHITE, color);
	removeCursor();
	printf("  ");
}

void erasePic(int x, int y)
{
	int i, j;
	removeCursor();
	for (i = 0; i <= 14; i++) {
		for (j = 0; j <= 14; j++) {
			if ((x + j) * 2 >= 0 && (x + j) * 2 < 80)
				erasestar((x + j) * 2, y + i);
		}
	}
}
void animatePacmanRight(int x, int y)
{
	int i, j;
	int first1[14] = { 4,2,1,1,0,0,0,0,0,0,1,1,2,4 };
	int last1[14] = { 9,11,12,12,11,9,6,5,6,10,12,12,10,9 };
	int first2[14] = { 4,2,1,1,0,0,0,0,0,0,1,1,2,4 };
	int last2[14] = { 8,10,11,11,12,12,12,12,12,12,11,11,10,8 };
	if (f == 0) {
		for (i = 0; i < 14; i++) {
			for (j = first1[i]; j <= last1[i]; j++) {
				if ((x + j) * 2 >= 0 && (x + j) * 2 < 79)
					printPacmanDotImage((x + j) * 2, y + i);
			}
		}
	}
	else {
		for (i = 0; i < 14; i++) {
			for (j = first2[i]; j <= last2[i]; j++) {
				if ((x + j) * 2 >= 0 && (x + j) * 2 < 79)
					printPacmanDotImage((x + j) * 2, y + i);
			}
		}
	}
}

void animatePackmanLeft(int x, int y)
{
	int i, j;
	if (f == 0) {
		for (i = 0; i < 14; i++) {
			for (j = 0; j < 14; j++) {
				if ((x + j) * 2 >= 0 && (x + j) * 2 < 79) {
					if (leftpacman1[i][j] == '1');
					gotoxy((x + j) * 2, y + i);
					textcolor(BLACK, YELLOW2);
					printf("  ");
				}
			}
		}
	}
	else {
		for (i = 0; i < 14; i++) {
			for (j = 0; j < 14; j++) {
				if ((x + j) * 2 >= 0 && (x + j) * 2 < 79) {
					if (leftpacman2[i][j] == '1');
					gotoxy((x + j) * 2, y + i);
					textcolor(BLACK, YELLOW2);
					printf("  ");
				}
			}
		}
	}
}

void animateGhostRight(int x, int y, int color)
{
	int i, j;
	for (i = 0; i < 14; i++) {
		if (f == 0) {
			for (j = 0; j < 14; j++) {
				if ((x + j) * 2 >= 0 && (x + j) * 2 < 79) {
					if (rightghost1[i][j] == '1')
						printGhostDotImage((x + j) * 2, y + i, color);
					else if (rightghost1[i][j] == '2')
						printGhostDotImage((x + j) * 2, y + i, WHITE);
					else if (rightghost1[i][j] == '3')
						printGhostDotImage((x + j) * 2, y + i, BLUE1);
				}
			}
		}
		else {
			for (j = 0; j < 14; j++) {
				if ((x + j) * 2 >= 0 && (x + j) * 2 < 79) {
					if (rightghost2[i][j] == '1')
						printGhostDotImage((x + j) * 2, y + i, color);
					else if (rightghost2[i][j] == '2')
						printGhostDotImage((x + j) * 2, y + i, WHITE);
					else if (rightghost2[i][j] == '3')
						printGhostDotImage((x + j) * 2, y + i, BLUE1);
				}
			}
		}
	}
}

void flicker(int x, int y, int n)
{
	int i;
	textcolor(WHITE, BLACK);
	if (n == 0) {
		for (i = 0; i < 4; i++) {
			gotoxy(34, y); printf("           ");
			Sleep(50);
			textcolor(WHITE, BLACK);
			gotoxy(34, 25); printf("GAME START");
			gotoxy(34, 27); printf("RANKING");
			gotoxy(34, 29); printf("HELP");
			gotoxy(34, 31); printf("EXIT");
			Sleep(50);
		}

	}
	else {
		for (i = 0; i < 4; i++) {
			gotoxy(34, y); printf("                ");
			Sleep(50);
			textcolor(WHITE, BLACK);
			gotoxy(34, 16); printf("SINGLE MODE");
			gotoxy(34, 18); printf("COOPERATION MODE");
			gotoxy(34, 20); printf("BATTLE MODE");
			Sleep(50);
		}
	}
	Sleep(100);
}

void showArrow(int x, int y, int n)
{
	gotoxy(x - 4, y);
	textcolor(WHITE, BLACK);
	printf("▶");

	if (y != n)
		erasestar(x - 4, n);
	if (y != n + 2)
		erasestar(x - 4, n + 2);
	if (y != n + 4)
		erasestar(x - 4, n + 4);
	if (y != n + 6)
		erasestar(x - 4, n + 6);
}

int selectMode()
{
	int ch;
	int arrow = SINGLEMODE;
	cls(BLACK, BLACK);
	gotoxy(34, 16); printf("SINGLE MODE");
	gotoxy(34, 18); printf("COOPERATION MODE");
	gotoxy(34, 20); printf("BATTLE MODE");
	while (1) {
		Sleep(100);
		if (kbhit() == 1) {
			ch = getch();
			if (ch == SPACE || ch == ENTER) {
				flicker(34, (arrow % 3) * 2 + 16, 1);
				return arrow % 3 + SINGLEMODE;
			}
			else if (ch == SPECIAL1 || ch == SPECIAL2) {
				ch = getch();
				if (ch == UP)
					arrow--;
				else if (ch == DOWN)
					arrow++;
			}
		}
		if (arrow % 3 == 0)		showArrow(34, 16, 14);
		else if (arrow % 3 == 1)	showArrow(34, 18, 16);
		else if (arrow % 3 == 2)	showArrow(34, 20, 18);
	}
}
int selectGameMode()
{
	int ch;
	int arrow = GAMESTART;
	int i = 0;
	cls(BLACK, BLACK);
	while (1) {
		animatePacmanRight(-14 + i, 4);
		animateGhostRight(-40 + i, 4, RED2);
		animateGhostRight(-55 + i, 4, MAGENTA2);
		animateGhostRight(-70 + i, 4, CYAN2);
		animateGhostRight(-85 + i, 4, YELLOW1);
		Sleep(200);
		erasePic(-14 + i, 4);
		erasePic(-40 + i, 4);
		erasePic(-55 + i, 4);
		erasePic(-70 + i, 4);
		erasePic(-85 + i, 4);
		f = (f == 0 ? 1 : 0); i += 5;
		if (i > 180)
			i = 0;

		if (kbhit() == 1) {
			ch = getch();
			if (ch == SPACE || ch == ENTER) {
				flicker(34, (arrow % 4) * 2 + 25, 0);
				if (arrow % 4 + 100 == GAMESTART) {
					return selectMode();
				}
				return arrow % 4 + GAMESTART;
			}
			else if (ch == SPECIAL1 || ch == SPECIAL2) {
				ch = getch();
				if (ch == UP)
					arrow--;
				else if (ch == DOWN)
					arrow++;
			}
		}
		if (arrow % 4 == 0)		showArrow(34, 25, 25);
		else if (arrow % 4 == 1)	showArrow(34, 27, 25);
		else if (arrow % 4 == 2)	showArrow(34, 29, 25);
		else if (arrow % 4 == 3)	showArrow(34, 31, 25);
		textcolor(WHITE, BLACK);
		printLineBox(27, 24, 10, 7);
		gotoxy(34, 25); printf("GAME START");
		gotoxy(34, 27); printf("RANKING");
		gotoxy(34, 29); printf("HELP");
		gotoxy(34, 31); printf("EXIT");
	}
}

void printState()
{
	int i;
	cls(BLACK, WHITE);
	printMap(map1);
	drawbox();
	showItem();
	showObject(object);
	printInGameStatus();
	pacman1(0);
	if (mode != SINGLE)
		pacman2(0);
}

void animateReadyStart()
{
	textcolor(WHITE, BLACK);
	gotoxy(27, 14);	printf("STAGE %d", stage + 1);
	gotoxy(28, 15);	printf("READY");
	removeCursor();
	Sleep(2500);
	gotoxy(28, 15);
	textcolor(YELLOW2, BLACK);
	printf("START");
	Sleep(500);
	gotoxy(28, 15);	printf("       ");
	gotoxy(27, 14);	printf("       ");
}


int pause()
{
	int i;
	static int arrow = 0;
	int select = -1;
	unsigned char ch;
	cls(BLACK, WHITE);
	while (1) {
		if (kbhit() == 1) {
			ch = getch();
			if (ch == SPACE || ch == ENTER)
				select = arrow % 4;
			else if (ch == SPECIAL1 || ch == SPECIAL2) {
				ch = getch();
				if (ch == UP || ch == UP2)
					arrow--;
				else if (ch == DOWN || ch == DOWN2)
					arrow++;
				else if (ch == RIGHT || ch == RIGHT2)
					select = arrow % 4;
			}
		}

		if (select == 0)
			break;
		switch (select) {
		case 1:
			return 0;
			break;
		case 2:
			break;
		case 3:
			exit(0);
			break;
		}

		if (arrow % 4 == 0)		showArrow(34, 12, 12);
		else if (arrow % 4 == 1)	showArrow(34, 14, 12);
		else if (arrow % 4 == 2)	showArrow(34, 16, 12);
		else if (arrow % 4 == 3)	showArrow(34, 18, 12);
		textcolor(WHITE, BLACK);
		gotoxy(34, 12); printf("RESUME");
		gotoxy(34, 14); printf("MAIN MENU");
		gotoxy(34, 16); printf("HELP");
		gotoxy(34, 18); printf("EXIT");
		Sleep(100);
	}
	printState();
	for (i = 0; i < GHOST; i++)
		ghostA(i, g[i].status);
	animateReadyStart();

}

int singleMode()
{
	int i, v = 1; //p는 게임 종료변수, (goto함수의 미사용을 위하여)
	unsigned char ch = 0;
	int numGHOST;
	int condition = 0;

	initGhost(); // 유령 제자리!
	initPacman(); // 팩맨 제자리!
	printState(); // 화면 출력
	animateReadyStart(); // 준비... 시작!
	init_Queue();
	while (1) {
		showItem();
		numGHOST = stage + 4;
		for (i = 0; i < numGHOST; i++) { // 유령 움직임, 출력
			ghostA(i, g[i].status);
		}
		if (kbhit() == 1) { // 키 입력 받기
			ch = getch();
			if (ch == ESC || ch == 'p')
				pause();

			if (ch == SPECIAL1 || ch == SPECIAL2) {
				ch = getch();
				if (peekNow(0) == NULL)
					dir_Queue1[present] = ch;
				enqueue_dir(0, ch);
				switch (peekNow(0)) {
				case UP:
				case DOWN:
				case LEFT:
				case RIGHT:
					if (pacman1(peekNow(0)) == 0) {
						return 1;
					}
					break;
				default:
					if (pacman1(0) == 0)
						return 1;
				}
			}
		}
		else {
			if (map1[p[0].ny][p[0].nx / 2] != '0' && ch != peekNow(0)) {
				replace_dir(0, p[0].nx, p[0].ny);
				if (pacman1(peekNow(0)) == 0)
					return 1;
			}
			else
				if (pacman1(0) == 0)
					return 1;
		}
		if (p == 0)
			break;
		printInGameStatus();
		Sleep(Delay);
	}
}
void cooperationMode()
{
	int i;
	int p = 1, q = 1;
	unsigned char ch;
	int numGHOST = stage + 6;
	C[0] = C[1] = 1;

	initGhost(); // 유령 제자리!
	initPacman(); // 팩맨 제자리!
	printState(); // 화면 출력
	animateReadyStart(); // 준비... 시작!
	init_Queue();


	while (1) { // 게임실행의 loof
		showItem();
		printInGameStatus();
		for (i = 0; i < numGHOST; i++) {
			ghostA(i, g[i].status);
		}
		if (kbhit() == 1) {
			ch = getch();
			if (ch == ESC || ch == 'p')
				pause();
			if (ch == SPECIAL1 || ch == SPECIAL2) {
				ch = getch();
				switch (C[0] == 1 ? ch : 0) {
				case UP:
				case DOWN:
				case LEFT:
				case RIGHT:
					p = pacman1(ch);
					q = pacman2(0);
					break;
				default:
					p = pacman1(0);
					q = pacman2(0);
				}
			}
			else {
				switch (C[1] == 1 ? ch : 0) {
				case UP2:
				case DOWN2:
				case LEFT2:
				case RIGHT2:
					q = pacman2(ch);
					p = pacman1(0);
					break;
				default:
					p = pacman1(0);
					q = pacman2(0);
				}
			}
		}
		else {
			p = pacman1(0);
			q = pacman2(0);
		}
		if (p == 0 || q == 0) // 스테이지를 클리어한다면
			break;	// 게임실행부의 무한루프를 벗어나 main menu로 이동한다.
		Sleep(Delay);
	}
}

void battleMode()
{
	int i;
	unsigned char ch;
	int numGHOST = stage + 6;

	initGhost(); // 유령 제자리!
	initPacman(); // 팩맨 제자리!
	printState(); // 화면 출력
	animateReadyStart(); // 준비... 시작!
	init_Queue();

	while (1) {
		showItem();
		for (i = 0; i < numGHOST; i++) {
			ghostA(i, g[i].status);
		}
		if (kbhit() == 1) {
			ch = getch();
			if (ch == ESC || ch == 'p')
				pause();
			if (ch == 't')
				exit(0);
			if (ch == SPECIAL1 || ch == SPECIAL2) {
				ch = getch();
				switch (ch) {
				case UP:
				case DOWN:
				case LEFT:
				case RIGHT:
					pacman1(ch);
					pacman2(0);
					break;
				default:
					pacman1(0);
					pacman2(0);
				}
			}
			else {
				switch (ch) {
				case UP2:
				case DOWN2:
				case LEFT2:
				case RIGHT2:
					pacman2(ch);
					pacman1(0);
					break;
				default:
					pacman1(0);
					pacman2(0);
				}
			}
		}
		else {
			pacman1(0);
			pacman2(0);
		}
		Sleep(Delay);
	}
}

void printDotStringRank(int x, int y)
{
	int i, j;
	for (i = 0; i < 5; i++) {
		for (j = 0; j < 19; j++) {
			//Sleep(10);
			if (Rankch[i][j] == '1') {
				textcolor(BLACK, WHITE);
				gotoxy((x + j) * 2, y + i);
				printf("┼");
			}
		}
	}
}

void printDotStringHelp(int x, int y)
{
	int i, j;
	for (i = 0; i < 5; i++) {
		for (j = 0; j < 19; j++) {
			//Sleep(10);
			if (Helpch[i][j] == '1') {
				textcolor(BLACK, WHITE);
				gotoxy((x + j) * 2, y + i);
				printf("┼");
			}
		}
	}
}

void printDotImageMedal(int x, int y, int color)
{
	int i, j;
	for (i = 0; i < 8; i++) {
		for (j = 0; j < 7; j++) {
			if (Medal[i][j] == '1')
				textcolor(color, color);
			else if (Medal[i][j] == '2')
				textcolor(RED2, RED2);
			else if (Medal[i][j] == '3')
				textcolor(BLUE2, BLUE2);
			else if (Medal[i][j] == '4') {
				if (color == YELLOW2)
					textcolor(GRAY1, GRAY1);
				else if (color == GRAY1)
					textcolor(GRAY2, GRAY2);
				else if (color == YELLOW1)
					textcolor(GRAY2, GRAY2);
			}
			else textcolor(BLACK, BLACK);
			gotoxy((x + j) * 2, y + i);
			printf("  ");
		}
	}
}

void showRank()
{
	char showname[3][20];
	int score[3], i;
	char ch;
	cls(BLACK, BLACK);
	printDotStringRank(10, 5);
	printDotImageMedal(16, 12, YELLOW2);
	printDotImageMedal(5, 15, GRAY1);
	printDotImageMedal(27, 15, YELLOW1);
	if ((fp = fopen(FILENAME, "r+b")) == NULL) {
		printf("rank data를 찾을 수 없습니다.\n");
	}

	fseek(fp, 0, SEEK_SET);
	for (i = 0; i < 3; i++) {
		fread(&data, sizeof(data), 1, fp);
		strcpy(showname[i], data.name);
		score[i] = data.myscore;
	}
	textcolor(WHITE, BLACK);

	gotoxy(37, 22); printf("%s", showname[0]);
	gotoxy(37, 23); printf("%d", score[0]);
	gotoxy(15, 25); printf("%s", showname[1]);
	gotoxy(15, 26); printf("%d", score[1]);
	gotoxy(59, 25); printf("%s", showname[2]);
	gotoxy(59, 26); printf("%d", score[2]);

	fclose(fp);
	gotoxy(53, 33); printf("PLEASE PRESS ANY KEY :)");
	getch();
}

int getNumBerofData(FILE *fp)
{
	int filesize;
	int n;
	fseek(fp, 0, SEEK_END); // 끝으로 이동
	filesize = ftell(fp); // 파일 크기가 return 됨
	n = filesize / sizeof(Rank);
	return n;
}


void writeRank()
{
	int i, ndata;
	int top[3] = { 0, };
	char powername[3][20];
	char player[20];

	cls(BLACK, BLACK);
	///showRanking();
	if ((fp = fopen(FILENAME, "r+b")) == NULL) { // 파일이 없으면
		fp = fopen(FILENAME, "w+b"); // 새로 생성
		strcpy(data.name, "NONE");
		data.myscore = 0;
		fseek(fp, 0, SEEK_SET); // 처음으로 이동
		fwrite(&data, sizeof(data), 1, fp);
		fwrite(&data, sizeof(data), 1, fp);
		fwrite(&data, sizeof(data), 1, fp);
		if (fp == NULL) {
			printf("파일을 열 수 없습니다.\n");
			exit(0);
		}
	}
	ndata = getNumBerofData(fp);

	fseek(fp, 0, SEEK_SET); // 처음으로 이동
	for (i = 0; i < 3; i++) { // 1~3위의 점수와 이름을 저장
		if (ndata == 0)
			break;
		fread(&data, sizeof(data), 1, fp);
		top[i] = data.myscore;
		strcpy(powername[i], data.name);
	}
	fseek(fp, 0, SEEK_SET); // 처음으로 이동
	if (score < top[2]) return;
	else {
		if (score > top[0]) {// 내가 1등!
			gotoxy(10, 10); printf("YOU GOT THE FIRST!\n");
			gotoxy(10, 11); printf("1st's score : %d\n", top[0]);
			gotoxy(10, 12); printf("YOUR SCORE : %d\n", score);
			gotoxy(10, 13); printf("PLEASE ENTER YOUR NAME> "); scanf("%s", player);
			strcpy(data.name, player);
			data.myscore = score;
			fwrite(&data, sizeof(data), 1, fp);

			strcpy(data.name, powername[0]);
			data.myscore = top[0];
			fwrite(&data, sizeof(data), 1, fp);

			strcpy(data.name, powername[1]);
			data.myscore = top[1];
			fwrite(&data, sizeof(data), 1, fp);
		}
		else if (score > top[1]) { // 내가 2등!
			gotoxy(10, 10); printf("YOU GOT THE SECOND!\n");
			gotoxy(10, 11); printf("2nd's score : %d\n", top[1]);
			gotoxy(10, 12); printf("YOUR SCORE : %d\n", score);
			gotoxy(10, 13); printf("PLEASE ENTER YOUR NAME> "); scanf("%s", player);
			fseek(fp, sizeof(data), SEEK_SET);
			strcpy(data.name, player);
			data.myscore = score;
			fwrite(&data, sizeof(data), 1, fp);

			strcpy(data.name, powername[1]);
			data.myscore = top[1];
			fwrite(&data, sizeof(data), 1, fp);
		}
		else if (score > top[2]) { // 내가 3등!
			gotoxy(10, 10); printf("YOU GOT THE THIRD!\n");
			gotoxy(10, 11); printf("3rd's score : %d\n", top[2]);
			gotoxy(10, 12); printf("YOUR SCORE : %d\n", score);
			gotoxy(10, 13); printf("PLEASE ENTER YOUR NAME:"); scanf("%s", player);
			fseek(fp, 2 * sizeof(data), SEEK_SET);
			strcpy(data.name, player);
			data.myscore = score;
			fwrite(&data, sizeof(data), 1, fp);
		}
	}
	fclose(fp);
}

void printHelpTextBox()
{
	int i, j;
	cls(BLACK, BLACK);
	printDotStringHelp(11, 4);
	textcolor(WHITE, BLACK);
	gotoxy(8, 10);
	printf("┏");
	gotoxy(8, 32);
	printf("┗");
	gotoxy(70, 32);
	printf("┛");
	gotoxy(70, 10);
	printf("┓");

	for (i = 10; i < 70; i += 2) {
		gotoxy(i, 10);
		printf("━");
		gotoxy(i, 32);
		printf("━");
	}
	for (i = 11; i < 32; i++) {
		gotoxy(8, i);
		printf("┃");
		gotoxy(70, i);
		printf("┃");
	}
	gotoxy(60, 32); printf(" ▼ ");
}

void print_helptext()
{
	printHelpTextBox();
	gotoxy(33, 11); printf("※게임 설명※");
	gotoxy(11, 15); printf(" 주인공인 팩맨을 조작하여 스테이지의 모든 코인을 먹으면");
	gotoxy(11, 16); printf("클리어입니다.");
	gotoxy(11, 18); printf(" 스테이지에 돌아다니는 유령들과 마주치면 라이프 하나를 잃");
	gotoxy(11, 19); printf("게되고 모든 라이프가 소진되면 GAME OVER입니다.");
	gotoxy(11, 21); printf(" 맵상의 특수한 아이템을 먹게되면 유령들이 주눅들게 됩니다.");
	gotoxy(11, 22); printf("팩맨은 주눅든 유령을 잡아먹을 수 있고, 잡아먹힌 유령은 집");
	gotoxy(11, 23); printf("으로 귀환했다가 다시 부활합니다.");
	gotoxy(11, 25); printf(" 유령을 포식하는 것은 코인 보다 더 많은 점수를 얻습니다.");
	gotoxy(11, 26); printf("고득점을 노린다면 유령을 많이 잡아먹으세요!");
	getch();
}

void main()
{
	int select;
	system("mode con: cols=80 lines=37");
	cls(BLACK, WHITE);
	srand(time(NULL));

	while (1) { // 메인메뉴의 loof
		initObject();
		select = selectGameMode(); // 메뉴 선택
		switch (select) {
		case SINGLEMODE:
			mode = SINGLE;
			if (singleMode() == 1) {
				writeRank();
			}
			break;
		case COOPERATIONMODE:
			mode = COOPERATION;
			cooperationMode();
			break;
		case BATTLEMODE:
			mode = BATTLE;
			battleMode();
			break;
		case RANKING:
			showRank();
			break;
		case HELP:
			print_helptext();
			break;
		case EXIT:
			gotoxy(30, 35);
			exit(0);
			break;
		} // 게임이 종료됨
		initGame();
	}
}